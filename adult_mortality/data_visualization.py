# -*- coding: utf-8 -*-
"""FINAL-ATA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pTLbjxjTD3l1AMjJe6FzWgPeKbM-l9nL
"""

import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

from google.colab import drive

drive.mount('/content/drive/')

cd 'drive/My Drive/Colab Notebooks'

mortality = pd.read_csv('FINAL_DATASET.csv')
X = mortality.drop(columns = ['DateModified', 'Adult mortality rate', 'Unnamed: 0'], axis = 1)
y = mortality['Adult mortality rate']

y

from sklearn.tree import DecisionTreeClassifier 
dt = DecisionTreeClassifier()

X['ParentLocation'].unique()
newloc = X['Location'].unique()
newloc.sort()

Ploc = {
    'Eastern Mediterranean' : 0,
    'Africa' : 1,
    'Europe': 2, 
    'Western Pacific' : 3,
    'Americas' : 4, 
    'South-East Asia' : 5
}

SexM = {
    'Male': 0,
    'Female': 1
}

X['ParentLocation'] = X['ParentLocation'].map(Ploc)

len(X['Location'].unique())

import pandas as pd
pd.options.mode.chained_assignment = None 
bX = X.copy()
newX = bX.sort_values(['Location']) #ROWS IN DATASET

print(len(newX))
print(newX['Location'].unique()[1])
print(len(newX['Location'].unique()))
for i in range(50):
  print(newX['Location'].unique()[i], i)

trial = dict()
for i in range(len(newX['Location'].unique())):
    # here define what key is, for example,
    key = newX['Location'].unique()[i]
    # check if key is already present in dict
    if key not in trial:
        trial[key] = []
    # append some value 
    trial[key].append(i)

bX['Location'] = bX['Location'].map(trial)

#trial2 = str(newX['Location'].replace('[','').replace(']',''))
trial2 = str(bX['Location'])[1:-1]
print(trial2)

trial

print(len(newX))
print(len(newX['Location'].unique()))

bX

y_try = y

y_new = y
round(y_new)
newy = y_new.astype(int)
newy

#removes brackets from location
newest = [i[0] for i in bX['Location']]
bX['Location'] = newest
bX['Sex'] = X['Sex'].map(SexM)

bX = bX.drop(columns = ['ParentLocation'], axis = 1)

bX['Sex'] = X['Sex'].map(SexM)

bX

#changing elements of array
def amr_category(num):
  if(num > 306):
    num = "HIGH"
    return num
  elif(num <= 306 and num >= 194):
    num = "MODERATE"
    return num
  elif(num < 194):
    num = "LOW"
    return num

y_try = y_try.apply(lambda x: amr_category(x))

y = y_try

# from sklearn.model_selection import train_test_split
# X_train, X_test, Y_train, Y_test = train_test_split(bX,y, test_size = 0.2)

from sklearn.model_selection import train_test_split
X_train, X_test, Y_train, Y_test = train_test_split(bX,newy, test_size = 0.2)

newy

#Create a function with many machine learning models
def models(X_train, Y_train):
  
  from sklearn.linear_model import LogisticRegression
  #log = LogisticRegression(random_state =0)
  log = LogisticRegression(solver='lbfgs', max_iter=100) 
  log.fit(X_train, Y_train)

  #Use Neighbors
  from sklearn.neighbors import KNeighborsClassifier
  knn = KNeighborsClassifier(n_neighbors =5, metric = 'minkowski', p=2)
  knn.fit(X_train, Y_train)

  #Use SVC (linear kernel)
  from sklearn.svm import SVC
  svc_lin = SVC(kernel ='linear', random_state =0)
  svc_lin.fit(X_train, Y_train)

  #Use SVC (RBF kernel)
  from sklearn.svm import SVC
  svc_rbf = SVC(kernel ='rbf', random_state =0)
  svc_rbf.fit(X_train, Y_train)

  #Use GaussianNB
  from sklearn.naive_bayes import GaussianNB
  gauss = GaussianNB()
  gauss.fit(X_train, Y_train)

  #Use Desicion Tree
  from sklearn.tree import DecisionTreeClassifier
  tree = DecisionTreeClassifier(criterion ='entropy', random_state=0)
  tree.fit(X_train, Y_train)

  #Use RandomForest Classifier
  from sklearn.ensemble import RandomForestClassifier
  forest = RandomForestClassifier(n_estimators =10, criterion = 'entropy', random_state =0)
  forest.fit(X_train, Y_train)

  #Print the training accuracy for each model
  print("[0]Logistic Regression Training Accuracy: ", log.score(X_train, Y_train))
  print("[1]K Neighbors Training Accuracy: ", knn.score(X_train, Y_train))
  print("[2]SVC Linear Training Accuracy: ", svc_lin.score(X_train, Y_train))
  print("[3]SVC RBF Training Accuracy: ", svc_rbf.score(X_train, Y_train))
  print("[4]Gaussian NB Training Accuracy: ", gauss.score(X_train, Y_train))
  print("[5]Decision Tree Training Accuracy: ", tree.score(X_train, Y_train))
  print("[6]Random Forest Training Accuracy: ", forest.score(X_train, Y_train))

  return log, knn, svc_lin, svc_rbf, gauss, tree, forest

model = models(X_train.values, Y_train.values)

from sklearn.preprocessing import  StandardScaler
sc = StandardScaler()
amr_vals = [[135, 2000, 1]]
amr_scaled = sc.fit_transform(amr_vals) 

pred = model[1].predict(amr_vals)

print(pred)

import seaborn as sns

#count low, moderate, and high values
sns.countplot(y)

#visualize who has the highest mortality rate
fig, ax = plt.subplots(figsize=fig_dims)
sns.barplot(x="ParentLocation", y="Adult mortality rate", data=mortality, ax = ax)

#create new variable to store all in the csv
z = mortality.drop(columns = ['DateModified', 'Unnamed: 0'], axis = 1)

africa = z.loc[z['ParentLocation'] == 'Africa']

#for sizing of box 
fig_dims = (10, 12)
fig, ax = plt.subplots(figsize=fig_dims)

#because africa is the highest, this finds out what country has the highest MR
sns.barplot(x="Adult mortality rate", y="Location", data=africa, ax = ax)

#mortality rate for africa
sns.barplot(x="ParentLocation", y="Adult mortality rate", hue="Period", data=africa)

#mortality rate for Eastern Mediterranean
sns.barplot(x="ParentLocation", y="Adult mortality rate", hue="Period", data=eastern)

#mortality rate for Europe
sns.barplot(x="ParentLocation", y="Adult mortality rate", hue="Period", data=europe)

#mortality rate for Western Pacific
sns.barplot(x="ParentLocation", y="Adult mortality rate", hue="Period", data=western)

#mortality rate for Americas
sns.barplot(x="ParentLocation", y="Adult mortality rate", hue="Period", data=america)

#mortality rate for SEA
sns.barplot(x="ParentLocation", y="Adult mortality rate", hue="Period", data=sea)

sns.barplot(x="Adult mortality rate", y="ParentLocation", data=mortality, ax = ax)

sns.barplot(x = "Sex", y="Adult mortality rate", data = z)

sns.barplot(x="Adult mortality rate", y="ParentLocation", data=z)

africa = z.loc[z['ParentLocation'] == 'Africa']

try1

africa2016 = z[['ParentLocation','Period', 'Sex', 'Adult mortality rate']][(z["Period"] == 2016) & (z["ParentLocation"] == 'Africa') ]
africa2000 = z[['ParentLocation','Period', 'Sex', 'Adult mortality rate']][(z["Period"] == 2000) & (z["ParentLocation"] == 'Africa') ]
eastern2k16 = z[['ParentLocation','Period', 'Sex', 'Adult mortality rate']][(z["Period"] == 2016) & (z["ParentLocation"] == 'Eastern Mediterranean') ]
eastern2000 = z[['ParentLocation','Period', 'Sex', 'Adult mortality rate']][(z["Period"] == 2000) & (z["ParentLocation"] == 'Eastern Mediterranean') ]
europe2k16 = z[['ParentLocation','Period', 'Sex', 'Adult mortality rate']][(z["Period"] == 2016) & (z["ParentLocation"] == 'Europe') ]
europe2000 = z[['ParentLocation','Period', 'Sex', 'Adult mortality rate']][(z["Period"] == 2000) & (z["ParentLocation"] == 'Europe') ]
western2k16 = z[['ParentLocation','Period', 'Sex', 'Adult mortality rate']][(z["Period"] == 2016) & (z["ParentLocation"] == 'Western Pacific') ]
western2000 = z[['ParentLocation','Period', 'Sex', 'Adult mortality rate']][(z["Period"] == 2000) & (z["ParentLocation"] == 'Western Pacific') ]
americas2k16 = z[['ParentLocation','Period', 'Sex', 'Adult mortality rate']][(z["Period"] == 2016) & (z["ParentLocation"] == 'Americas') ]
americas2000 = z[['ParentLocation','Period', 'Sex', 'Adult mortality rate']][(z["Period"] == 2000) & (z["ParentLocation"] == 'Americas') ]
sea2k16 = z[['ParentLocation','Period', 'Sex', 'Adult mortality rate']][(z["Period"] == 2016) & (z["ParentLocation"] == 'South-East Asia') ]
sea2000 = z[['ParentLocation','Period', 'Sex', 'Adult mortality rate']][(z["Period"] == 2000) & (z["ParentLocation"] == 'South-East Asia') ]

africa = z.loc[z['ParentLocation'] == 'Africa']
eastern = z.loc[z['ParentLocation'] == 'Eastern Mediterranean']
europe = z.loc[z['ParentLocation'] == 'Europe']
western = z.loc[z['ParentLocation'] == 'Western Pacific']
america = z.loc[z['ParentLocation'] == 'Americas']
sea = z.loc[z['ParentLocation'] == 'South-East Asia']

sns.barplot(x="ParentLocation", y="Adult mortality rate", hue="Period", data=africa)

cols = [africa, eastern, europe, western, america, sea]
n_rows =2
n_cols =3

#Sublot grid and figure size of each graph
fig, axs = plt.subplots(n_rows, n_cols, figsize = (n_cols *3.2, n_rows *3.2)) 

for r in range(0, n_rows):
  for c in range(0, n_cols):

    i = r*n_cols + c # indexing of columns
    ax = axs[r][c] # Show position of subplots
    sns.barplot(x="ParentLocation", y="Adult mortality rate", hue="Period", data=cols[i])
    #ax.set_title(cols[i])
    #ax.legend(title = 'survived', loc ='upper right')
  plt.tight_layout()

#OPTIONAL
#Calculation
def get_ls_mean(x,df):
  parentloc = x['ParentLocation']
  period = x['Period']
  ls_mean = df.query(f"ParentLocation == {parentloc} and Period == {period}")['Adult mortality rate'].mean()
  if str(ls_mean) != 'nan':
    return ls_mean
  else:
    ls_mean = df.query(f"ParentLocation == {location} and Period == {period}")['Adult mortality rate'].mean()
    return 0

z['prev_mean'] = X.apply(lambda x: get_ls_mean(x,X),axis=1)